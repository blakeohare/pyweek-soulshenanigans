class LevelLibrary {
	
	field levels;
	static field instance = new LevelLibrary();
	
	constructor () {
		this.levels = {};
	}
	
	static function get_level(level_key) {
		level_data = LevelLibrary.instance.levels.get(level_key);
		if (level_data == null) {
			LevelLibrary.instance.load_level(level_key);
		}
		return new Level(LevelLibrary.instance.levels[level_key]);
	}
	
	function load_level(level_key) {
		lines = Resources.readText('levels/levels/' + level_key + '.txt').split('\n');
		
		values = {};
		width = 0;
		victory = -1;
		tile_keys = [];
		start_locations = null;
		default_start = null;
		doors = [];
		background = null;
		background_scroll = 0;
		enemies = [];
		storm = false;
		music = 'overworld1';
		for (line : lines) {
			line = line.trim();
			if (line.length > 0) {
				line = line.split(':');
				item = line[0];
				line = line[1:].join(':').trim();
				switch (item) {
					case 'width':
						width = parseInt(line);
						break;
					case 'tiles':
						tile_keys = line.split(' ');
						break;
					//case 'victoryX':
					//	values['victoryX'] = parseInt(line);
					//	break;
					case 'default_start':
						values['default_start'] = line;
						break;
					case 'start_locations':
						start_locations = line;
						break;
					case 'background_image':
						storm = line == 'stormy1';
						background = ImageLibrary.INSTANCE.Get('backgrounds/' + line + '.png');
						break;
					case 'music':
						music = line;
						break;
					case 'background_scroll_rate':
						background_scroll = parseFloat(line);
						break;
					case 'doors':
						if (line.length > 0) {
							for (door : line.split(' ')) {
								parts = door.split('|');
								coords = parts[0].split(',');
								dest = parts[1].split(',');
								doors.add([parseInt(coords[0]), parseInt(coords[1]), dest[0], dest[1]]);
							}
						}
						break;
					case 'enemies':
						if (line != '') {
							for (enemy : line.split(' ')) {
								parts = enemy.split(',');
								enemy_type = parts[0];
								x = parseInt(parts[1]);
								y = parseInt(parts[2]);
								enemies.add([enemy_type, x, y]);
							}
						}
						break;
					default:
						Core.assert(false, "Unknown map field: '" + item + "'");
						break;
				}
			}
		}
		
		values['enemies'] = enemies;
		values['storm'] = storm;
		values['doors'] = doors;
		values['start_locations'] = {};
		values['background'] = background;
		values['background_scroll'] = background_scroll;
		values['music'] = music;
		for (loc : start_locations.split(' ')) {
			parts = loc.split(',');
			values['start_locations'][parts[0]] = [parseInt(parts[1]), parseInt(parts[2])];
		}

		tiles = [];
		x = 0;
		y = 0;
		
		victory_found = false;
		
		previous_is_up_incline = false;
		for (tile_key : tile_keys) {
			keys = tile_key.split(',');
			if (keys.length == 1) {
				tiles.add(tile_library.GetTile(x * 16, y * 16, keys[0]));
			} else {
				tiles.add(tile_library.GetCompositeTile(x * 16, y * 16, keys));
			}
			
			is_victory = false;
			
			for (key : keys) {
				if (key == 'b2' && !victory_found) {
					is_victory = true;
					values['victoryX'] = x * 16 + 8;
					victory_found = true;
				}
			}
			
			if (tiles.length > 1 && tiles[-1].has_down_inclines()) {
				tiles[-2].remove_walls(false);
				previous_is_up_incline = false;
			} else if (tiles[-1].has_up_inclines()) {
				previous_is_up_incline = true;
			} else if (previous_is_up_incline) {
				tiles[-1].remove_walls(true);
				previous_is_up_incline = false;
			} else {
				previous_is_up_incline = false;
			}
			
			x += 1;
			if (x == width) {
				x = 0;
				y += 1;
			}
		}
		
		this.levels[level_key] = new LevelTemplate(tiles, width, values);
		this.levels[level_key]._remove_me = level_key //TODO: remove me
	}
}
