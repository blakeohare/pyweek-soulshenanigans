
class Level {
	constructor(level_template) {
		this.level_template = level_template;
		this.random_start = 0;
	}
	
	function get_tile(col, row) {
		return this.level_template.get_tile(col, row);
	}
	
	function get_width() {
		return this.level_template.get_width();
	}
	
	function get_height() {
		return this.level_template.get_height();
	}
	
	function Refresh() {
		levels.load_level(this.level_template._remove_me);
		this.level_template = levels.levels[this.level_template._remove_me];
		// levels.load_level(this.level_template._remove_me)
		// levels.levels[this.level_template._remove_me] = this.level_template
	}
	
	function get_enemies() {
		enemies = [];
		for (enemy : this.level_template.values['enemies']) {
			x = enemy[1] * 16;
			y = enemy[2] * 16;
			switch (enemy[0]) {
				case 'bat': sprite = new EnemyBat(x, y); break;
				case 'skeleton': sprite = new EnemySkeleton(x, y); break;
				case 'burrower': sprite = new EnemyBurrow(x, y); break;
				case 'greenblob': sprite = new EnemyBlob(x, y, 'green'); break;
				case 'blueblob': sprite = EnemyBlob(x, y, 'blue'); break;
				case 'redblob': sprite = EnemyBlob(x, y, 'red'); break;
				case 'jellyfish': sprite = EnemyJellyFish(x, y); break;
				case 'orc': sprite = EnemyOrc(x, y); break;
				case 'earththingy': sprite = EnemyThingy(x, y, 'earth'); break;
				case 'frostthingy': sprite = EnemyThingy(x, y, 'frost'); break;
				case 'flarethingy': sprite = EnemyThingy(x, y, 'flare'); break;
				default: Core.assert(false, "Unknown sprite type: " + enemy[0]); break;
			}
			sprite.x += sprite.width / 2;
			sprite.y -= sprite.height / 2 + 1;
			enemies.add(sprite);
		}
		return enemies;
	}
	
	function get_door_dest(x, y) {
		for (door : this.level_template.values['doors']) {
			if (door[0] == x && door[1] == y) {
				return [door[2], door[3]];
			}
		}
		return null;
	}
	
	function get_background_image(counter) {
		if (this.level_template.values['storm']) {
			foo = counter % 2000 / 100;
			if (foo == 1 || foo == 3 || foo == 11 || foo == 15) {
				val = counter % 100;
				if (val >= 2 && val <= 13) {
					val = val / 2;
					return images.Get('backgrounds/stormy' + val + '.png');
				}
			}
		}
		return this.level_template.values['background'];
	}
	
	function get_background_offset(counter) {
		return int(counter * this.level_template.values['background_scroll']);
	}
	
	function get_victory_x() {
		return self.level_template.values['victoryX'];
	}
	
	function get_start_location(name = null) {
		if (name == null) {
			name = this.level_template.values['default_start'];
		}
		
		if (name == null) {
			return [1, 1];
		}
		
		return this.level_template.values['start_locations'][name];
	}
	
	static field LANDING_PLATFORMS = ['solid', 'jumpthrough', 'blocking', 'incline'];
	static field WALL_PLATFORMS = ['solid'];
	static field CEILING_PLATFORMS = ['solid', 'blocking'];
	static field INCLINE_PLATFORMS = ['incline'];
	
	function get_landing_platforms_in_rectangle(xStart, xEnd, yStart, yEnd) {
		return getPlatformsInRectangle(xStart, xEnd, yStart, yEnd, Level.LANDING_PLATFORMS);
	}
	
	function get_walls_in_rectangle(xStart, xEnd, yStart, yEnd) {
		return getPlatformsInRectangle(xStart, xEnd, yStart, yEnd, Level.WALL_PLATFORMS);
	}
	
	function get_ceilings_in_rectangle(xStart, xEnd, yStart, yEnd) {
		return getPlatformsInRectangle(xStart, xEnd, yStart, yEnd, Level.CEILING_PLATFORMS);
	}
	
	function get_inclines_in_rectangle(xStart, xEnd, yStart, yEnd) {
		return getPlatformsInRectangle(xStart, xEnd, yStart, yEnd, Level.INCLINE_PLATFORMS);
	}
	
	function getPlatformsInRectangle(xStart, xEnd, yStart, yEnd, types) {
		
		xStart = Math.max(0, xStart);
		xEnd = Math.min(xEnd, this.get_width() - 1);
		yStart = Math.max(0, yStart);
		yEnd = Math.min(yEnd, this.get_height() - 1);
		
		landing = [];
		
		tiles = this.level_template.tiles;
		width = this.level_template.width;
		
		for (x = xStart; x <= xEnd; ++x) {
			for (y = yStart; y <= yEnd; ++y) {
				p = tiles[y * width + x].get_platforms();
				for (type : types) {
					landing.concat(p[type]);
				}
			}
		}
		return landing;
	}
}
