import Math;

class PlayScreen {
	field counter = 0;
	field render_counter = 0;
	field next = this;
	field g = 1.4;
	field water_g = .2;
	
	field level_id;
	field level_info;
	field screen_id; // what is this?
	
	field renderInventory = true;
	field target_vx = 0;
	field player;
	field enemies;
	field powerups = [];
	field mumblefoo = null;
	field wibblywobby;
	field wibblywobbly_counter = 0;
	
	field allow_enemy_edit = true; // TODO: create a release $var for this.
	field enemy_edit_mode = false;
	field wand_cooldown = 0;
	field wand_charge = 0;
	field bullets = [];

	field other_sprites = [];
	
	field camera_x;
	field camera_y;
	
	field text_triggers = {
		'timer': [],
		'soul_pickup': null,
	};
	
	constructor (level, screen, start_location=None) {
		
		this.level_id = level
		this.screen_id = screen
		this.level_info = levels.get_level(this.level_id + screen)
		
		start_loc = this.level_info.get_start_location(start_location)
		
		this.player = MainCharacter(start_loc[0] * 16, start_loc[1] * 16 + 1)
		this.enemies = this.level_info.get_enemies()
		
		this.wibblywobbly = new WibblyWobblyRenderer();
	
		camera_offset = this.get_real_camera_offset();
		this.camera_x = camera_offset[0] + 0.0;
		this.camera_y = camera_offset[1] + 0.0;
		
		if (this.level_id == '0_1') {
			this.text_triggers['timer'] = [
					[
						10, 
						["Wow, I never realized how ",
						"much misplacing a soul could",
						"make my mind and body go all",
						"wibbly wobbly. It seems one",
						"of the larger chunks fell into",
						"the bushes over there."].join('\n'),
						null]
					]
			this.text_triggers['soul_pickup'] = [
				["Phew, if I didn't pick that up",
				"sooner it may have been",
				"game over for me.",
				"I better be careful not to",
				"drop this again!"].join('\n'),
				new TransitionScene(this, new MapScene(1, '1'), 'fadeout', 30)];
			
			
			this.mumblefoo = new SoulJar(230, 224 - 50, 0);
			this.wibblywobbly_counter = 60;
			this.mumblefoo.vx = 0;
			this.mumblefoo.vy = 0;
		}
		
		if (this.level_id == '3_5' && this.screen_id == 'a') {
			
			this.text_triggers['timer'] = [
					[1, "Curious, I don't recall his\ncastle being this gloomy. He\nmust have remodelled recently.", null]
					];
		}
		
		if (games.active_game() != null) {
			
			if (games.active_game().get_value('wand_1') != 1 && 
				this.level_id == '1_3' &&
				this.screen_id == 'b') {
				this.powerups.append(new Powerup(88, 40, 'wand_1'));
			}
			
			if (games.active_game().get_value('wand_2') != 1 && 
				this.level_id == '2_1' &&
				this.screen_id == 'b') {
				this.powerups.append(new Powerup(90 + 9 * 16, 80, 'wand_2'));
			}
			
			if (games.active_game().get_value('wand_3') != 1 &&
				this.level_id == '2_5' &&
				this.screen_id == 'c') {
				this.powerups.append(new Powerup(152, 48, 'wand_3'));
			}
			
			// TODO
			if (games.active_game().get_value('wand_4') != 1 &&
				this.level_id == '3_3' &&
				this.screen_id == 'b') {
				this.powerups.append(new Powerup(40, 40, 'wand_4'));
			}
			
			if (this.level_id == '1_5' &&
				this.screen_id == 'c') {
				this.powerups.append(new Powerup(14 * 16, 32, 'mumblefoo_piece1'));
			}
			
			if (this.level_id == '2_5' &&
				this.screen_id == 'd') {
				this.powerups.append(new Powerup(31 * 16, 10 * 16, 'mumblefoo_piece2'));
			}
			
			if (this.level_id == '3_5' &&
				this.screen_id == 'c') {
				this.enemies.append(EnemyCornelius(220, 80));
			}
		}
	}
		
	function get_sprites() {
		
		sprites = [];
		if (this.mumblefoo != null) {
			sprites.add(this.mumblefoo);
		}
		sprites.add(this.player);
		sprites.concat(this.powerups);
		sprites.concat(this.enemies);
		sprites.conat(this.other_sprites);
		
		return sprites;
	}
	
	
	function get_real_camera_offset() {
		width = this.level_info.get_width();
		height = this.level_info.get_height();
		x = this.player.x - 128;
		y = this.player.y - 112;
		x = max(min(x, width * 16 - 256), 0);
		y = max(min(y, height * 16 - 224), 0);
		return [x, y];
	}
	
	function get_camera_offset() {
		return [floor(this.camera_x), floor(this.camera_y)];
	}
	
	function update_camera() {
		new_coord = this.get_real_camera_offset();
		this.camera_x = this.camera_x * 0.7 + new_coord[0] * 0.3;
		this.camera_y = this.camera_y * 0.7 + new_coord[1] * 0.3;
	}
	
	function get_walls(x_left, x_right, y_top, y_bottom) {
		tile_left = (x_left - 1) / 16;
		tile_right = (x_right + 1) / 16;
		tile_top = (y_top - 1) / 16;
		tile_bottom = (y_bottom + 1) / 16;
		
		platforms = [];
		
		for (tile_x = tile_left; tile_x < tile_right; ++tile_x) {
			for (tile_y = tile_top; tile_y < tile_bottom; ++tile_y) {
				platforms.concat(this.level_info.get_tile(tile_x, tile_y).get_platforms()['solid']);
			}
		}
				
		return platforms;
	}
	
	function get_landing_surfaces(x, y_top, y_bottom) {
		tile_left = (x - 1) / 16;
		tile_right = (x + 1) / 16;
		tile_top = (y_top - 1) / 16;
		tile_bottom = (y_bottom + 1) 16;
		
		return this.level_info.get_landing_platforms_in_rectangle(tile_left - 1, tile_right + 1, tile_top, tile_bottom);
	}
	
	function get_ceilings(x, y_top, y_bottom) {
		tile_left = (x - 1) / 16;
		tile_right = (x + 1) / 16;
		tile_top = (y_top - 1) / 16;
		tile_bottom = (y_bottom + 1) / 16;
		
		return this.level_info.get_ceilings_in_rectangle(tile_left, tile_right, tile_top, tile_bottom);
	}
	
	function get_just_inclines(x_left, x_right, y_top, y_bottom) {
		tile_left = (x_left / 16) - 1;
		tile_right = (x_right / 16) + 1;
		tile_top = (y_top / 16) - 1;
		tile_bottom = (y_bottom / 16) + 1;
		
		return this.level_info.get_inclines_in_rectangle(tile_left, tile_right, tile_top, tile_bottom);
	}
	
	function IsPlatformOn(pixel_x, pixel_y) {
		x = pixel_x / 16;
		y = pixel_y / 16;
		return this.level_info.get_landing_platforms_in_rectangle(x, x, y, y).length > 0;
	}
	
	function ProcessInput(events) {
		
		x = Math.floor(this.player.x) / 16;
		y = Math.floor(this.player.y) / 16;
		current_tile = this.level_info.get_tile(x, y);
		below_tile = this.level_info.get_tile(x, y + 1);
		above_tile = this.level_info.get_tile(x, y - 1);
		
		in_water = current_tile.is_water();
		on_ladder = current_tile.is_ladder();
		ladder_above = above_tile.is_ladder();
		ladder_below = below_tile.is_ladder();
		on_death_tile = current_tile.is_kill();
		on_ouch_tile = current_tile.is_ouch();
		
		for (event : events) {
			if (event.key == 'start' && event.down) {
				this.next = new TransitionScene(this, PauseScene(this), 'fade', 10);
				jukebox.MakeQuiet();
			} else if (event.key == 'B') {
				// jump
				if (event.down && (this.player.on_ground || in_water || this.player.holding_ladder)) {
					if (in_water) {
						this.player.vy = -4;
					} else {
						this.player.vy = -15;
					}
					this.player.holding_ladder = false;
					this.player.on_ground = false;
					this.player.platform = null;
				} else if (this.player.vy < 0) {
					this.player.vy = 0;
				}
			} else if (event.key == 'Y' && event.down) {
				if (this.wand_cooldown <= 0 && this.bullets.length < 5 && wandStatus.DepleteMagic()) {
					this.wand_cooldown = 5;
					this.bullets.add(new Bullet(this.player.left_facing, this.player.x, this.player.y, wandStatus.SelectedWand()));
				}
			} else if (event.key == 'Y' && event.up && this.wand_charge > 10) {
				if (wandStatus.SelectedWand() == 4) {
					charge = Math.max(0, Math.min(2, Math.floor((this.wand_charge - 10) / 30.0))); // TODO: ensure range?
					this.bullets.add(new Bullet(this.player.left_facing, this.player.x, this.player.y, wandStatus.SelectedWand(), charge));
					this.wand_charge = 0;
				}
			} else if (event.key == 'L' && event.up) { // TODO: remove this before shipping
				this.level_info.Refresh();
			}
		}
		
		running = input.is_key_pressed('A') && (not in_water);
		
		if (input.is_key_pressed('Y')) {
			this.wand_charge++;
		} else {
			this.wand_charge = 0;
		}
		
		if (input.is_key_pressed('left')) {
			this.player.left_facing = true;
			this.target_vx = running ? -5 : -3;
		} else if (input.is_key_pressed('right')) {
			this.player.left_facing = false;
			this.target_vx = running ? 5 : 3;
		} else {
			this.target_vx = 0;
		}
		
		if (in_water) {
			if (this.player.on_ground)
				this.target_vx /= 3.0;
			else
				this.target_vx /= 1.3;
		}
		
		if (this.wand_cooldown > 0)
			this.target_vx = 0;
		
		screechiness = 0.6; // TODO: make this dynamic for low-friction ice levels
		if (this.target_vx != this.player.vx) {
			if (this.target_vx > this.player.vx) {
				this.player.vx = Math.min(this.target_vx, this.player.vx + screechiness);
			} else if (this.target_vx < this.player.vx) {
				this.player.vx = max(this.target_vx, this.player.vx - screechiness);
			}
		}
	}
	
	function Update() {
		this.counter++;
		this.wand_cooldown--;
		
		if (this.counter == 1) {
			//print 'attempting to play: ', this.level_info.level_template.values['music']
			jukebox.PlayLevelMusic(this.level_info.level_template.values['music']);
		}
		
		camera = this.get_camera_offset();
		camera_x = camera[0];
		camera_y = camera[1];
		
		new_bullets = [];
		for (bullet : this.bullets) {
			bullet.update();
			if (bullet.is_off_screen(camera_x, camera_x + 256)) {
				bullet.void_this();
			}
			
			if (!bullet.expired)
				new_bullets.add(bullet);
		}
		
		this.bullets = new_bullets;
		
		if (this.allow_enemy_edit) {
			if (_enemyEdit.ModeToggled()) {
				this.enemy_edit_mode = !this.enemy_edit_mode;
				if (!this.enemy_edit_mode) {
					filename = 'levels/levels/' + this.level_id + this.screen_id + '.txt';
					lines = Resource.readText(filename).split('\n');
					c = open(filename, 'rt')
					output = ''
					for (line : lines) {
						parts = line.split(':');;
						if (!parts[0] == 'enemies') {
							output += line + '\r\n';
						}
					}
					
					enemies = [];
					for (enemy : this.level_info.level_template.values['enemies']) {
						enemies.add(enemy[0] + ',' + enemy[1] + ',' + enemy[2]);
					}
					
					if (enemies.length > 0) {
						output += 'enemies:' + ' '.join(enemies) + '\r\n';
					}
					
					// Also need to read from resource file on disk as opposed to embedded resources.
					Core.assert(false, "TODO: write back files to original resource file.");
					/*
					c = open(filename, 'wt')
					c.write(trim(output))
					c.close()
					//*/
				}
			}
			
			if (this.enemy_edit_mode) {
				num = _enemyEdit.NumPressed();
				if (num >= 0) {
					insert = null;
					switch (num) {
						case 1: insert = 'bat'; break;
						case 2: insert = 'skeleton'; break;
						case 3: insert = 'burrower'; break;
						case 4: insert = 'greenblob'; break;
						case 5: insert = 'blublob'; break;
						case 6: insert = 'redblob'; break;
						case 7: insert = 'jellyfish'; break;
						case 8: insert = 'orc'; break;
						case 10: insert = 'earththingy'; break;
						case 11: insert = 'frostthingy'; break;
						case 12: insert = 'flarethingy'; break;
						default: break;
					}
					
					if (insert != null) {
						this.level_info.level_template.values['enemies'].add((insert, Math.floor(this.player.x / 16), Math.floor(this.player.y / 16) + 1));
						this.enemies = this.level_info.get_enemies();
					}
				}
			}
		}
		
		for (sprite : this.get_sprites()) {
			
			if (sprite != this.player) {
				if (sprite.get_right() < camera_x - 48) continue;
				if (sprite.get_left() > camera_x + 256 + 48) continue;
				if (sprite.get_bottom() < camera_y - 48) continue;
				if (sprite.get_top() > camera_y + 224 + 48) continue;
			}
			
			x = Math.floor(sprite.x / 16.0);
			y = Math.floor(sprite.y / 16.0);
			
			current_tile = this.level_info.get_tile(x, y);
			in_water = current_tile.is_water();
			on_ladder = (this.player == sprite) && current_tile.is_ladder();
			ladder_above = (this.player == sprite) && this.level_info.get_tile(x, y - 1).is_ladder();
			ladder_below = (this.player == sprite) && this.level_info.get_tile(x, y + 1).is_ladder();
			residually_on_ladder = this.level_info.get_tile(x, Math.floor(sprite.get_bottom() / 16.0)).is_ladder();
			on_death_tile = current_tile.is_kill();
			on_ouch_tile = current_tile.is_ouch();
			
			if (sprite == this.player)
				this.player.holding_ladder = this.player.holding_ladder && (ladder_above || on_ladder || residually_on_ladder);
				
			sprite.update(this);
			
			if (this.player.special_state != null && this.player.special_state.block_update)
				continue;
			
			sprite.dx = sprite.vx;
			new_x = Math.floor(sprite.x + sprite.dx);
			
			sprite.walked_into_wall = false;
			
			if (sprite.confined_to_scene) {
				new_x = Math.max(2, Math.min(this.level_info.get_width() * 16 - 2, new_x));
			}
			
			if (!sprite.moves_through_walls) {
				
				if (sprite.dx > 0) { // going right
					wall = this.find_leftmost_wall_in_path(sprite.x, new_x, sprite.get_head_bonk_top(), sprite.get_bottom());
					if (wall != null) {
						new_x = wall.get_left_wall_x() - 1;
						sprite.vx = 0;
						sprite.walked_into_wall = true;
					}
				} else if (sprite.dx < 0) { // going left
					wall = this.find_rightmost_wall_in_path(new_x, sprite.x, sprite.get_head_bonk_top(), sprite.get_bottom());
					if (wall != null) {
						sprite.vx = 0;
						new_x = wall.get_right_wall_x() + 1;
						sprite.walked_into_wall = true;
					}
				}
			}
			
			// player may have possibly jumped through an incline
			if (!sprite.on_ground and new_x != sprite.x) {
				
				inclines = [];
				
				sprite_bottom = sprite.get_bottom();
				
				for (incline : this.get_just_inclines(Math.min(new_x, sprite.x) - 2, Math.max(new_x, sprite.x) + 2, sprite.y - 1, sprite.y + 1)) {
					
					// we're only interested in inclines in the horizontal component
					top = Math.min(incline.y_left, incline.y_right);
					bottom = Math.max(incline.y_left, incline.y_right);
					if (sprite_bottom >= top && sprite_bottom <= bottom) {
						// if new_x > sprite.x and incline.y_left > incline.y_right:
							inclines.add(incline);
						// elif new_x < sprite.x and incline.y_left < incline.y_right:
						// 	inclines.append(incline)
					}
				}
				
				for (incline : inclines) {
				
					starts_above = sprite_bottom < incline.get_y_at_x(sprite.x);
					ends_above = sprite_bottom < incline.get_y_at_x(new_x);
					
					if (starts_above && !ends_above) {
						sprite.x = incline.get_x_at_y(sprite.y);
						
						// if incline.is_x_in_range(new_x):
						sprite.platform = incline;
						sprite.on_ground = true;
						sprite.vy = 0;
						this.set_sprite_on_platform(sprite, incline);
						break;
					}
				}
			}
			
			sprite.x = new_x;
			
			
			if (!sprite.on_ground && !sprite.immune_to_gravity) {
				if (sprite == this.player && this.player.holding_ladder) {
					g = 0;
				} else if (in_water) {
					g = this.water_g;
				} else {
					g = this.g;
				}
				sprite.vy += g;
				sprite.vy = Math.min(sprite.vy, 13);
			} else {
				sprite.vy = 0;
			}
			
			sprite.dy = Math.floor(sprite.vy);
			
			if (sprite == this.player) {
			
				sprite.ladder_climb = input.is_key_pressed('up') || input.is_key_pressed('down');
				
				if (this.player.holding_ladder) {
					if (input.is_key_pressed('up')) {
						sprite.dy -= 1;
					} else if (input.is_key_pressed('down')) {
						sprite.dy += 1;
					}
				} else {
					if (ladder_below && input.is_key_pressed('down')) {
						sprite.y += 4;
						sprite.on_ground = false;
						sprite.platform = null;
						sprite.holding_ladder = true;
						sprite.vx = 0;
						sprite.dx = 0;
						sprite.vy = 0;
					} else if (on_ladder && input.is_key_pressed('up')) {
						
						sprite.vx = 0;
						sprite.vy = 0;
						sprite.dx = 0;
						this.player.holding_ladder = true;
						sprite.platform = null;
						sprite.on_ground = false;
						sprite.dy = -1;
					}
				}
			}
			
			new_y = sprite.y + sprite.dy;
			
			if (sprite.dy > 0) {
				// sprite is falling
				
				y_offset = sprite.get_bottom() - sprite.y;
				
				highest = this.find_highest_platform_in_path(sprite.x, sprite.y + y_offset, new_y + y_offset);
				
				if (highest != null) {
					sprite.on_ground = true;
					sprite.platform = highest;
					this.set_sprite_on_platform(sprite, highest);
				} else {
					sprite.y = new_y;
				}
			} else if (sprite.dy <= 0 && sprite.platform == null) {
				
				y_offset = sprite.get_head_bonk_top() - sprite.y;
				
				lowest = this.find_lowest_platform_in_path(sprite.x, new_y + y_offset, sprite.y + y_offset);
				
				if (lowest != null) {
					sprite.dy = 0;
					sprite.vy = 0;
					new_y = lowest.get_bottom() + y_offset;
					// TODO: play BONK noise
				} else {
					sprite.y = new_y;
				}
			} else {
				if (sprite.platform != null) {
					platform = sprite.platform;
					if (platform.is_x_in_range(sprite.x)) {
						this.set_sprite_on_platform(sprite, platform);
					} else {
						// player walked off edge of platform
						
						new_platform_found = false;
						
						// which way?
						if (sprite.x < platform.left) {
							// walked off left
							left = platform.left;
							for (left_platform : this.get_landing_surfaces(left - 1, sprite.y - 18, sprite.y + 18)) {
								
								// check to see if the right side of this platform is vertically aligned with 
								// the left side of the one you walked off
								if (Math.abs(left_platform.left + left_platform.width - platform.left) <= 1) {
									
									// check to see if they're vertically aligned
									if (Math.abs(left_platform.y_right - platform.y_left) <= 1) {
										sprite.platform = left_platform;
										break;
									}
								}
							}
						} else {
							// walked off right
							right = platform.left + platform.width;
							for (right_platform : this.get_landing_surfaces(right + 1, sprite.y - 18, sprite.y + 18)) {
								
								// check to see if the left side of this platform is vertically aligned with 
								// the right side of the one you walked off
								if (Math.abs(right_platform.left - (platform.left + platform.width)) <= 1) {
									
									// check to see if they're vertically aligned
									if (Math.abs(right_platform.y_left - platform.y_right) <= 1) {
										sprite.platform = right_platform;
										break;
									}
								}
							}
						}
						
						// if no new platform was found...
						if (sprite.platform == platform) {
							// the sprite has fallen off the edge
							sprite.on_ground = false;
							sprite.platform = null;
						}
					}
				}
			}
			
			if (sprite != this.player) {
				if (sprite.is_powerup) {
					// pass
				} else if (!sprite.invincible) {
					for (bullet : this.bullets) {
						if (sprite.is_collision_with_rect(bullet.x - 6, bullet.x + 6, bullet.y - 4, bullet.y + 4)) {
							bullet.void_this();
							sprite.killed = sprite.hit(bullet.get_additional_damage());
						}
					}
				}
			}
		}
		
		new_sprites = [];
		
		for (powerup : this.powerups) {
			if (powerup.is_collision_with_rect(this.player.get_left(), this.player.get_right(), this.player.get_top(), this.player.get_bottom())) {
				powerup.collected(self);
			} else {
				new_sprites.add(powerup);
			}
		}
		this.powerups = new_sprites;
		
		new_sprites = [];
		
		for (enemy : this.enemies) {
			if (!enemy.killed) {
				new_sprites.add(enemy);
			} else {
				powerup = enemy.GetPowerUp(this.counter, this);
				this.other_sprites.append(PoofCloud(enemy.x, enemy.y));
				if (powerup != null) {
					this.powerups.append(powerup);
				}
			}
		}
		
		this.enemies = new_sprites;
		
		new_sprites = [];
		
		for (foo : this.other_sprites) {
			if (!foo.expired) {
				new_sprites.append(foo);
			}
		}
		this.other_sprites = new_sprites;
		
		if (this.mumblefoo != null && this.mumblefoo.lifetime > 6) {
			if (this.is_collision(this.mumblefoo, this.player)) {
			
				this.wibblywobbly_counter = Math.min(this.wibblywobbly_counter, this.wibblywobbly.get_max_severity());
				this.mumblefoo = null;
				// TODO: play noise
				jukebox.MumblefooPickedUp();
				if (this.text_triggers['soul_pickup'] != null) {
					this.text_triggers['timer'].add((this.counter + 40, this.text_triggers['soul_pickup'][0], this.text_triggers['soul_pickup'][1]));
				}
			}
		}
		
		if (!this.enemy_edit_mode) {
			if (this.player.flashing_counter <= 0) {
				for (sprite : this.enemies) {
					if (this.is_collision(sprite, this.player)) {
						if (this.mumblefoo == null) {
							// You dropped the mumblefoo!
							jukebox.MumblefooDropped();
							this.mumblefoo = new SoulJar(this.player.x, this.player.y, this.counter);
						}
						this.vy = -4;
						this.player.flashing_counter = 60;
						if (this.player.left_facing) {
							this.vx = 5;
						} else {
							this.vx = -5;
						}
					}
				}
			}
		}
		
		if (this.mumblefoo == null) {
			this.wibblywobbly_counter = Math.max(0, this.wibblywobbly_counter - 5);
			
			// Check for door entry
			door = this.level_info.get_door_dest(Math.floor(this.player.x / 16), Math.floor(this.player.y / 16));
			if (door != null && this.player.special_state == null) {
				this.player.special_state = new SpecialStateDoorEntry(door, this.player);
			}
			
			// Check for victory
			victory_x = this.level_info.get_victory_x();
			if (victory_x > 0 && this.player.x >= victory_x && this.player.special_state == null) {
				//TODO: automated victory sequence
				games.active_game().save_value('finished_world' + this.level_id, 1);
				parts = this.level_id.split('_');
				world = Math.floor(parts[0]);
				level_from = Math.floor(parts[1][0]);
				level_to = '' + (level_from + 1);
				level_from = '' + level_from;
				if (level_to == '6') {
					level_to = 'next';
				}
				if (world == 0) {
					level_from = '1';
					level_to = '1';
					world = 1;
				}
				
				jukebox.PlayVictory();
				
				if (this.level_id == '3_5') {
					nextScene = new CutSceneScene('endgame', new CreditsScene());
				} else {
					nextScene = new MapScene(world, level_from, level_to);
				}
				
				this.player.special_state = new SpecialStateVictory(this.player, nextScene);
			}
		} else {
			this.wibblywobbly_counter++;
			if (this.player.special_state == null && this.wibblywobbly_counter > this.wibblywobbly.get_max_severity()) {
				if (this.level_id != '0_1') {
					this.kill_player();
				}
			}
		}
		
		if (this.player.special_state == null && this.player.y > this.level_info.get_height() * 16 + 30) {
			this.kill_player();
		}
		
		new_text_triggers = [];
		for (text_trigger : this.text_triggers['timer']) {
			if (this.counter >= text_trigger[0] && this.next == this) {
				this.next = TextOverlayScene(text_trigger[1], self, text_trigger[2]);
			} else {
				new_text_triggers.add(text_trigger);
			}
		}
		this.text_triggers['timer'] = new_text_triggers;
	}
	
	function get_left_stiched_platform(platform) {
		for (stiched : this.get_landing_surfaces(platform.left - 1, platform.y_left - 3, platform.y_left + 3)) {
			if (Math.abs(platform.y_left - stiched.y_right) <= 1 && abs(platform.left - stiched.left - stiched.width) <= 1) {
				return stiched;
			}
		}
		return null;
	}
		
	function get_right_stiched_platform(platform) {
		for (stiched : this.get_landing_surfaces(platform.left + platform.width + 1, platform.y_right - 3, platform.y_right + 3)) {
			if (Math.abs(platform.y_right - stiched.y_left) <= 1 && Math.abs(platform.left + platform.width - stiched.left) <= 1) {
				return stiched;
			}
		}
		return null;
	}
	
	function kill_player() {
		this.player.special_state = new SpecialStateDying(this.player);
		jukebox.PlayDeath();
	}
	
	function is_collision(spriteA, spriteB) {
		
		return spriteA.is_collision_with_rect(
			spriteB.get_left(),
			spriteB.get_right(),
			spriteB.get_top(),
			spriteB.get_bottom());
	}
	
	function set_sprite_on_platform(sprite, platform) {
		sprite.y = Math.floor(platform.get_y_at_x(sprite.x) - sprite.height + sprite.height / 2); // odd math to keep consistent rounding
	}
	
	function find_leftmost_wall_in_path(left_x, right_x, y_top, y_bottom) {
		return this._find_first_wall_in_path(left_x, right_x, y_top, y_bottom, true);
	}
	
	function find_rightmost_wall_in_path(left_x, right_x, y_top, y_bottom) {
		return this._find_first_wall_in_path(left_x, right_x, y_top, y_bottom, false);
	}
	
	function _find_first_wall_in_path(left_x, right_x, y_top, y_bottom, going_right) {
		furthest = null;
		
		platforms = this.get_walls(left_x, right_x, y_top, y_bottom);
		
		for (platform : platforms) { // all platforms are guaranteed to be solid type
			if (!(y_bottom <= platform.get_top() || y_top > platform.get_bottom())) {
				if (going_right) {
					wall_x = platform.left;
				} else {
					wall_x = platform.left + platform.width;
				}
				
				if (left_x <= wall_x && right_x >= wall_x) {
					if (furthest == null) {
						furthest = platform;
					} else if (going_right && furthest.left > platform.left) {
						furthest = platform;
					} else if (!going_right && furthest.left + furthest.width < platform.left + platform.width) {
						furthest = platform;
					}
				}
			}
		}
		return furthest;
	}
		
	function _find_first_platform_in_path(x, upper_y, lower_y, going_down) {
		furthest = null;
		
		if (going_down) {
			platforms = this.get_landing_surfaces(x, upper_y, lower_y);
		} else {
			platforms = this.get_ceilings(x, upper_y, lower_y);
		}
		
		for (platform : platforms) {
			if (platform.is_x_in_range(x)) {
				if (going_down) {
					platform_y = platform.get_y_at_x(x);
				} else {
					platform_y = platform.get_bottom();
				}
					
				if (upper_y <= platform_y && lower_y >= platform_y) {
					if (furthest == null) {
						furthest = platform;
					} else if (going_down && furthest.get_y_at_x(x) > platform_y) {
						furthest = platform;
					} else if (!going_down && furthest.get_bottom() < platform.get_bottom()) {
						furthest = platform;
					}
				}
			}
		}
		
		return furthest;
	}

	function find_highest_platform_in_path(x, upper_y, lower_y) {
		return this._find_first_platform_in_path(x, upper_y, lower_y, true);
	}

	function find_lowest_platform_in_path(x, upper_y, lower_y) {
		return this._find_first_platform_in_path(x, upper_y, lower_y, false);
	}
	
	function Render(screen) {
		this.render_counter++;
		
		this.update_camera();
		camera = this.get_camera_offset();
		cx = camera[0];
		cy = camera[1];
		
		bg = this.level_info.get_background_image(this.counter);
		if (bg != null) {
			scroll_width = this.level_info.get_width() * 16 - 256;
			
			if (scroll_width == 0)
				scroll_width = 1;
			
			bg_percent = (0.0 + cx) / scroll_width;
			bg_width = bg.get_width();
			
			bg_offset = -1 * bg_percent * (bg_width - 256);
			
			bg_offset += this.level_info.get_background_offset(this.render_counter);
			
			bg_offset = int(bg_offset % bg.get_width());
			bg.draw(bg_offset, 0);
			bg.draw(bg_offset - bg.width, 0);
		}
		
		col_start = Math.max(0, Math.floor(cx / 16 - 1));
		col_end = Math.min(this.level_info.get_width() - 1, col_start + 18);
		
		row_start = Math.max(0, Math.floor(cy / 16 - 1));
		row_end = Math.min(this.level_info.get_height() - 1, row_start + 16);
		
		for (row = row_start; row < row_end; ++row) {
			for (col = col_start; col < col_end; ++col) {
				x = col * 16;
				y = row * 16;
				tile = this.level_info.get_tile(col, row);
				imgs = tile.get_images(this.render_counter);
				if (imgs != null) {
					for (img : imgs) {
						if (img != null) {
							img.draw(x - cx, y - cy);
						}
					}
				}
			}
		}
		
		if (this.wibblywobbly_counter > 0) {
			this.wibblywobbly.render_color_fade(screen, this.render_counter, this.wibblywobbly_counter);
		}
		
		this.player.wand_cooldown = this.wand_cooldown;
		
		for (sprite : this.get_sprites()) {
			sprite.draw(this.player.vx != 0, this.counter, camera);
		}
		
		for (bullet : this.bullets) {
			bullet.draw(cx, cy);
		}
		
		if (this.wibblywobbly_counter > 0) {
			this.wibblywobbly.render(this.render_counter, this.wibblywobbly_counter);
		}

		this.render_status();
		
		if (this.enemy_edit_mode) {
			label = get_text("(enemy insertion mode)");
			label.draw(0, 0);
		}
	}
	
	function render_status() {
		if (this.renderInventory) {
			left = 256 - 10 - 100;
			top = 5;
			GFX.Draw.rectangle(left - 1, top - 1, 102, 8, 0, 0, 0);
			wand_width = wandStatus.GetMagic();
			colors = wandStatus.GetColors();
			color = colors[0];
			GFX.Draw.rectangle(left, top, wand_width, 5, color[0], color[1], color[2]);
			color = colors[1];
			GFX.Draw.rectangle(left, top + 2, wand_width, 3, color[0], color[1], color[2]);
			color = colors[2];
			GFX.Draw.rectangle(left, top + 4, wand_width, 2, color[0], color[1], color[2]);
		}
	}
}
