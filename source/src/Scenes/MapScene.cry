class MapScene {
	field next = this;
	field counter = 0;
	field world_num;
	field location;
	field nodes;
	field bg_image;
	field destination;
	field move_counter = 0;
	field facing_left = false;
	
	constructor (world_num, level, level_to = null) {
		games.active_game().save_value('intro_shown', 1)
		
		this.world_num = world_num;
		this.location = level;
		this.nodes = this._read_map_file();
		//TODO: set initial location from save game
		if (level_to != null) {
			this.destination = level_to;
		} else {
			this.destination = this.location;
		}
	}
		
	function Update() {
		this.counter++;
		
		if (this.counter == 1) {
			jukebox.PlayMapMusic();
		}
		
		if (this.destination != this.location) {
			this.move_counter++;
			
			if (this.move_counter >= 15) {
				this.move_counter = 0;
				this.location = this.destination;
				
				screenchange = null;
				if (this.location == 'prev') {
					screenchange = new MapScene(this.world_num - 1, 'next', '5');
				} else if (this.location == 'next') {
					screenchange = new MapScene(this.world_num + 1, 'prev', '1');
				}
				
				if (screenchange != null) {
					this.next = new TransitionScene(this, screenchange, 'fadeout', 30);
				}
			}
		}
	}
	
	function Render(screen) {
		
		if (this.bg_image == null) {
			this.bg_image = this.generate_map();
		}
		
		this.bg_image.blit(0, 0);
		
		flux = abs((this.counter % 30.0) - 15) / 15.0;
		half = floor(128 * flux);
		full = floor(255 * flux);
		
		complete_color = [half, half, 127 + half];
		incomplete_color = [full, 0, 0];
		for (node : self.nodes.values()) {
			color = incomplete_color;
			if (node['completed'] == 1) {
				color = complete_color;
			}
			x = node['x'];
			y = node['y'];
			GFX.Draw.ellipse(x - 8, y - 8, 16, 16, 0, 0, 0);
			GFX.Draw.ellipse(x - 6, y - 6, 12, 12, color[0], color[1], color[2]);
		}
		
		walking = this.location != this.destination;
		direction = this.facing_left ? 'left' : 'right';
		img = 'sprites/ClumsyWizard/' + direction;
		if (walking) {
			img += 'walk' + (this.counter / 3 % 3) + '.png';
		} else {
			img += 'stand.png';
		}
		
		character = ImageLibrary.Get(img);
		start_node = this.nodes[this.location];
		end_node = this.nodes[this.destination];
		start_x = start_node['x'];
		start_y = start_node['y'];
		end_x = end_node['x'];
		end_y = end_node['y'];
		x = floor(start_x * (15 - this.move_counter) / 15.0 + end_x * this.move_counter / 15.0 - character.get_width() / 2);
		y = floor(start_y * (15 - this.move_counter) / 15.0 + end_y * this.move_counter / 15.0 - character.get_height() / 2);
		character.blit(x, y - 10);
	}
	
	function ProcessInput(events) {
		for (event : events) {
			if (this.move_counter == 0) {
				node = this.nodes[this.location];
				if (event.down) {
					for (connection : node['connections']) {
						if (connection[1] == event.key) {
							if (node['completed'] || this.nodes[connection[0]]['completed']) {
								this.destination = connection[0];
								this.facing_left = this.nodes[this.location]['x'] > this.nodes[this.destination]['x'];
							}
							break;
						}
					}
				} else if (event.down && event.key in ('start', 'B', 'A'):
					nextScene = PlaySceneInfoScene(this.world_num, this.location)
					this.next = TransitionScene(this, nextScene, 'fadeout', 30)
					jukebox.FadeOut(2)
		
	
	def generate_map(self):
		original = images.Get('maps/world_' + str(this.world_num) + '.png')
		background = pygame.Surface((256, 224))
		background.blit(original, (0, 0))
		
		nodes = this.nodes
		
		color = (93, 72, 55)
		for start in nodes.keys():
			start_x = nodes[start]['x']
			start_y = nodes[start]['y']
			
			for end in nodes[start]['connections']:
				end_x = nodes[end[0]]['x']
				end_y = nodes[end[0]]['y']
				
				pygame.draw.aaline(background, color, (start_x, start_y), (end_x, end_y), 2)
				
				#for i in range(50):
				#	x = int(start_x * i / 50.0 + end_x * (50 - i) / 50.0)
				#	y = int(start_y * i / 50.0 + end_y * (50 - i) / 50.0)
				#	pygame.draw.circle(background, color, (x, y), 2)
		return background
	
	def _read_map_file(self):
		c = open(os.path.join('levels', 'world_map', 'world_' + str(this.world_num) + '.txt'), 'rt')
		lines = trim(c.read()).split('\n')
		c.close()
		nodes = {}
		connections = False
		for line in lines:
			line = trim(line)
			if not connections:
				if line == '#connections':
					connections = True
				else:
					parts = line.split('\t')
					id = parts[0]
					if this.location == '': // TODO: remove this when start location is loaded from saved game
						this.location = id
					coords = parts[1].split(',')
					x = int(coords[0])
					y = int(coords[1])
					nodes[id] = {
						'id' : id,
						'x' : x,
						'y' : y,
						'connections' : [],
						'completed' : (id == 'prev') or (games.active_game().get_value('finished_world' + str(this.world_num) + '_' + id) == 1)
					}
			else:
				parts = line.split('\t')
				left = parts[0]
				right = parts[1]
				direction = parts[2]
				nodes[left]['connections'].append((right, direction))
				nodes[right]['connections'].append((left, this._swap_direction(direction)))
				
		return nodes
	
	function _swap_direction(d) {
		switch (d) {
			case 'right': return 'left';
			case 'left': return 'right';
			case 'up': return 'down';
			case 'down': return 'up';
		}
	}
}